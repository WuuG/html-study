- [类名选择符与ID选择符](#类名选择符与id选择符)
	- [类名的连缀使用](#类名的连缀使用)
	- [ID选择符的问题](#id选择符的问题)
- [属性选择符](#属性选择符)
	- [简单属性选择器](#简单属性选择器)
	- [根据精准的属性值选择](#根据精准的属性值选择)
	- [根据部分属性值选择](#根据部分属性值选择)
		- [|=的示例](#的示例)
		- [匹配以空格分割的一组词的一个](#匹配以空格分割的一组词的一个)
		- [匹配属性值的字串](#匹配属性值的字串)
		- [匹配属性值开头的字串](#匹配属性值开头的字串)
		- [匹配属性值结尾的字串](#匹配属性值结尾的字串)
		- [不区分大小写的标识符](#不区分大小写的标识符)
- [根据文档结构选择](#根据文档结构选择)
	- [选择紧邻同胞](#选择紧邻同胞)
	- [选择后续同胞节点](#选择后续同胞节点)
- [伪类选择器](#伪类选择器)
	- [拼接伪类](#拼接伪类)
	- [结构伪类](#结构伪类)
		- [选择根元素](#选择根元素)
		- [选择空元素](#选择空元素)
		- [选择唯一的子代](#选择唯一的子代)
		- [选择每第n个元素](#选择每第n个元素)
		- [选择每第n中元素](#选择每第n中元素)
	- [动态伪类](#动态伪类)
		- [超链接伪类](#超链接伪类)
		- [用户操作伪类](#用户操作伪类)
	- [UI状态伪类](#ui状态伪类)
# 类名选择符与ID选择符
## 类名的连缀使用
连缀使用的类名,表示需要同时包含多个类名，才会渲染
``` html
	<p class="urgent warning ">测试类名连缀</p>
	<p class="urgent  ">测试类名连缀</p>
```
当用下面的样式时，上面的选择上了，下面的没有被选择上。
``` css
p.urgent.warning {
	color: skyblue;
}
```
## ID选择符的问题
规范上一个文档只能有一个ID值，但是若确实存在一个重复ID，对html和css而言还是会渲染，且相同的样式是都会应用上的(对新版edge而言)。但对于JavaScript的DOM操作而言会带来麻烦。
# 属性选择符
## 简单属性选择器
``` html
	<h1 class="sliver">Hello</h1>
	<h1>World</h1>
	<h1 class="haha">HTML</h1>
```
下面的样式会匹配存在class属性的h1标签。也就是上面的第1和第3个。
``` css
h1[class] {
	color: silver;
}
```
也可以多个属性连缀选择
``` html
	<!-- 第一个被选择上，第二个没有 -->
	<a href=":javascript" title="">属性选择器</a>
	<a href=":javascript">属性选择器</a>
```
``` css
a[href][title] {
	text-decoration: none;
}
```
## 根据精准的属性值选择
字符串完全相同的属性值选择
``` js
	<!-- 第一个匹配，第二个没有匹配 -->
	<a href="http://www.baidu.com">百度</a>
	<a href="https://www.baidu.com">百度</a>
```
``` css
a[href="http://www.baidu.com"] {
	color: red;
}
```
## 根据部分属性值选择
+ [foo|="bar"] 选择的元素有foo属性，且其值以bar和一个引文破折号(String.fromCharCode('0x002D'))开头,或者就是bar本身
+ [foo~="bar"] 选择的元素有foo属性，且其值是包含bar这个词的一组词
+ [foo*="bar"] 选择的元素有foo属性，且其值包含字串bar
+ [foo^="bar"] 选择的元素有foo属性，且其值以bar开头
+ [foo$="bar"] 选择的元素有foo属性，且其值以bar结尾

### |=的示例
``` html
	<!-- 只有前两个会匹配 -->
	<h1 lang="en">Hello</h1>
	<h1 lang="en-us">Hello</h1>
	<h1 lang="enus">Hello</h1>
	<h1 lang="cy-en">Hello</h1>
```
``` css
h1[lang|=en] {
	color: red;
}
```
对于一个CSS框架或模式库，没必要提供"btn btn-small btn-arrow btn-active"这样的类,可以声明btn-small-arrow-active来作为类名，就可以 *[class|="btn"]来进行选择。

### 匹配以空格分割的一组词的一个
下面的会匹配，其实下面的效果和类选择器是一样的。 但是属性选择器不仅仅能作用与class属性，还可以作用于其他属性。
``` html
	<span class="word text">选择一组词的一个</span>
``` 
``` css
span[class~="text"] {
	color: salmon;
}
```
### 匹配属性值的字串
匹配字串
``` html
	<a href="http://www.zhihu.com">知乎</a>
	<a href="https://www.zhihu.com">知乎</a>
```
``` css
a[href*="zhihu"] {
	color: sienna;
}
```
字串匹配*常与和|结合使用，如前例,可如下匹配active的btn
``` html
	<button  class="btn-small-arrow-active"></button>
```
``` css
*[class|="btn"][class*="active"] {
 background-color: blueviolet;
}
```
> 这种选择符做的都是精确匹配，也就是说区分大小写空白等。但HTML属性值中的关键字是不区分大小写的。
### 匹配属性值开头的字串
例如对于不同协议的链接，或者alt属性是Figure开头的插图，以及title是Monday进行选择。下例为不同的协议的类型设定了不同样式:
``` html
	<a href="http://www.bilibili.com">bilibili</a>
	<a href="malito://www.bilibili.com">bilibili</a>
```
``` css
a[href^="http"] {
	color:burlywood
}
a[href^="mailto"] {
	color:cyan
}
```
### 匹配属性值结尾的字串
常用与根据目标资源的类型进行选择
### 不区分大小写的标识符
CSS Selector Level4 为属性选择符引入了一个不区分大小写的选项。在结束方括号前加入i，匹配属性是就不区分大小写。
``` html
	<h2 title="PNG">不区分大小写</h2>
```
``` css
h2[title="png" i] {
	color:darkslategray
}
```
# 根据文档结构选择
## 选择紧邻同胞
通过紧邻同胞连结符(adjacent-silibing combinator)，通过+号选择紧邻在其后的兄弟节点。
``` html
	<div>
		<ol>
			<li>1</li>
			<li>2</li>
			<li>3</li>
		</ol>
		中间的文本，对于+选择无影响
		<ul>
			<li>1</li>
			<li>2</li>
			<li>3</li>
		</ul>
	</div>
```
``` css
div ol+ul li {
	color: skyblue;
}
```
## 选择后续同胞节点
一般同胞连结符(general sibling combinator),使用波浪号~表示，选择一个元素后面通俗一个父元素的另一个元素。
``` html
	<div>
		<h1>一级标题</h1>
		<h2>二级标题</h2>
		<p>段落</p>
	</div>
```
``` css
div h1~p {
	color:tomato;
}
```
# 伪类选择器
伪类选择器(pseudo-class selector)
## 拼接伪类
伪类是能够拼接的，如下就是将未访问过且鼠标悬停起上的链接的字体颜色设置为红色。 
``` css
a:link:hover {
	color: red;
}
```
## 结构伪类
伪类始终指代所依附的元素。算是对选择出的元素的特定描述。

### 选择根元素
通过:root伪类选择文档的根元素。对HTML文档来说就是指\<html>
``` css
:root {
	border:3px solid gray
}
```
### 选择空元素
:empty伪类可以选择没有任何自带的元素。下例中只有未被选择上的p一个有空格，一个有换行符。 :empty若是全部匹配有个副作用，会导致HTMl中的空元素如img和input也被匹配上。
``` html
	<p></p><!--被选择上-->
	<p> </p> 
	<p>
	</p>
	<p><!--注释--></p><!--被选择上-->
	<img src="" alt=""> <!--被选择上-->
	<input type="text"> <!--被选择上-->
```
``` css
:empty {
	width: 20px;
	height: 20px;
	background-color: red;
}
```
### 选择唯一的子代
:only-child伪类，其选择的元素是另一个元素唯一的子元素。
``` html
	<a href="https://www.baidu.com"><img src="./baidu-icno.png" alt=""></a> <!--被选择上-->
	<a href="https://www.baidu.com"><img src="./baidu-icno.png" alt="">百度</a> <!--被选择上-->
	<a href="https://www.baidu.com"><img src="./baidu-icno.png" alt=""> <em>百度</em></a> 
	<a href="https://www.baidu.com"> <em><img src="./baidu-icno.png" alt="">百度</em></a> <!--被选择上-->
```
``` css
a img:only-child {
	width: 200px;
}
```
:only-of-type,匹配父元素唯一的那种元素。这里的type指的唯一的元素，
``` html
	<div>
		<a href="https://www.baidu.com"> <img src="./baidu-icno.png" alt=""><em>百度</em><span>span</span></a>
	</div>
```
``` css
div img:only-of-type {
	width: 20px;
}
```
这里的p2不会匹配上，因为类型值的是元素类型。和前面选择的东西没有关系。
``` html
	<div>
		<p>p1</p>
		<p class="p2">p2</p>
	</div>
```
``` css
div p[class]:only-of-type {
	color: red;
}
```
### 选择每第n个元素
若是:nth-child()需要使用到负数，需要使用减号，而不是直接+负数。如下例，没有一个会被span匹配。
``` html
	<div>
		<span>第1个span</span><span>第2个span</span><span>第3个span</span><span>第4个span</span>
	</div>
```
``` css
span:nth-child(2n + -1) { /* 无效的选择器 */
	color: red;
}
```
:nth-last-child(),从后往前选择的伪类。

结合使用:nth-child()和:nth-last-child()可以确定列表有多少列表项目，然后据此装饰。
``` css
li:only-child {background-color: green;} 
li:nth-child(1):nth-last-child(2) ,li:nth-child(2):nth-last-child(1){background-color:rosybrown;}
li:nth-child(1):nth-last-child(3),li:nth-child(1):nth-last-child(3)~li {background-color: sienna;}
li:nth-child(1):nth-last-child(4),li:nth-child(1):nth-last-child(4)~li {background-color: tomato;}
```
### 选择每第n中元素
:nth-of-type和:nth-last-of-type
## 动态伪类
### 超链接伪类
+ :link 超链接的锚记，指向尚未访问的地址
+ :visited 指代已访问的超链接。

为什么需要link来指代a元素呢？因为直接用a标签来指代未访问过的链接的话，会导致\<a>\</a>也会应用上样式。
### 用户操作伪类
+ :focus 指代当前获得输入焦点的元素。
+ :hover 指代将鼠标指针放置其上的元素。
+ :active 指代由用户输入激活的元素。

可以处于:active状态的元素有链接、菜单项目，以及可以设定tabindex属性的元素。这些元素，加上其他所有交互元素还可以获得焦点。
> 伪类之间存在顺序"link-visited-focus-hover-active"
## UI状态伪类
用户界面状态伪类
+ enabled 指代启用的用户界面元素。即接受输入的元素
+ disabled 指代禁用的用户界面元素。即不接受输入的元素
+ checked 指代由用户或文档默认选中的单选按钮或复选框
+ indeterminate 指代既未选中也没有未选中的单选按钮或复选框<?>。这个状态只能由DOM设定，不能用户设定。
+ default 指代默认选中的单选按钮、复选框或选项
+ valid 指代满足所有数据有效性语义的输入框<--表单验证？
+ invalid 指代不满足所有数据有效性语义的输入框
+ in-range 指代输入的值在最小值和最大值之间的输入框
+ out-of-range 指代输入的值小与空间允许的最小值或大于空间允许的最大值的输入框
+ required 指代必须输入值的输入框
+ optional 指代无需一定输入值的输入框
+ read-write 指代可由用户编辑的输入框
+ read-only 指代不能由用户编辑的输入框
### 启用和禁用UI元素
可以通过DOM脚本或者在HTML5元素的标记中添加disabled属性。
``` html
	<label for="name">名字:</label><input type="text" id="name">
	<label for="email">邮箱:</label><input type="text" id="email" disabled>
```
``` css
input:enabled {
	background-color: silver;
}
input:disabled {
	background-color: red;
}
```
### 选择状态